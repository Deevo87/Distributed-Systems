# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.10
#
# <auto-generated>
#
# Generated from file `generate.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module SmartHome
_M_SmartHome = Ice.openModule('SmartHome')
__name__ = 'SmartHome'

if 'Info' not in _M_SmartHome.__dict__:
    _M_SmartHome.Info = Ice.createTempClass()
    class Info(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    Info.Failure = Info("Failure", 0)
    Info.Working = Info("Working", 1)
    Info._enumerators = { 0:Info.Failure, 1:Info.Working }

    _M_SmartHome._t_Info = IcePy.defineEnum('::SmartHome::Info', Info, (), Info._enumerators)

    _M_SmartHome.Info = Info
    del Info

if 'AlreadyWorkingError' not in _M_SmartHome.__dict__:
    _M_SmartHome.AlreadyWorkingError = Ice.createTempClass()
    class AlreadyWorkingError(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHome::AlreadyWorkingError'

    _M_SmartHome._t_AlreadyWorkingError = IcePy.defineException('::SmartHome::AlreadyWorkingError', AlreadyWorkingError, (), False, None, ())
    AlreadyWorkingError._ice_type = _M_SmartHome._t_AlreadyWorkingError

    _M_SmartHome.AlreadyWorkingError = AlreadyWorkingError
    del AlreadyWorkingError

if 'DeviceFailureError' not in _M_SmartHome.__dict__:
    _M_SmartHome.DeviceFailureError = Ice.createTempClass()
    class DeviceFailureError(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHome::DeviceFailureError'

    _M_SmartHome._t_DeviceFailureError = IcePy.defineException('::SmartHome::DeviceFailureError', DeviceFailureError, (), False, None, ())
    DeviceFailureError._ice_type = _M_SmartHome._t_DeviceFailureError

    _M_SmartHome.DeviceFailureError = DeviceFailureError
    del DeviceFailureError

_M_SmartHome._t_Device = IcePy.defineValue('::SmartHome::Device', Ice.Value, -1, (), False, True, None, ())

if 'DevicePrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.DevicePrx = Ice.createTempClass()
    class DevicePrx(Ice.ObjectPrx):

        def setInfo(self, info, context=None):
            return _M_SmartHome.Device._op_setInfo.invoke(self, ((info, ), context))

        def setInfoAsync(self, info, context=None):
            return _M_SmartHome.Device._op_setInfo.invokeAsync(self, ((info, ), context))

        def begin_setInfo(self, info, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.Device._op_setInfo.begin(self, ((info, ), _response, _ex, _sent, context))

        def end_setInfo(self, _r):
            return _M_SmartHome.Device._op_setInfo.end(self, _r)

        def getInfo(self, context=None):
            return _M_SmartHome.Device._op_getInfo.invoke(self, ((), context))

        def getInfoAsync(self, context=None):
            return _M_SmartHome.Device._op_getInfo.invokeAsync(self, ((), context))

        def begin_getInfo(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.Device._op_getInfo.begin(self, ((), _response, _ex, _sent, context))

        def end_getInfo(self, _r):
            return _M_SmartHome.Device._op_getInfo.end(self, _r)

        def isFailure(self, context=None):
            return _M_SmartHome.Device._op_isFailure.invoke(self, ((), context))

        def isFailureAsync(self, context=None):
            return _M_SmartHome.Device._op_isFailure.invokeAsync(self, ((), context))

        def begin_isFailure(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.Device._op_isFailure.begin(self, ((), _response, _ex, _sent, context))

        def end_isFailure(self, _r):
            return _M_SmartHome.Device._op_isFailure.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.DevicePrx.ice_checkedCast(proxy, '::SmartHome::Device', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.DevicePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::Device'
    _M_SmartHome._t_DevicePrx = IcePy.defineProxy('::SmartHome::Device', DevicePrx)

    _M_SmartHome.DevicePrx = DevicePrx
    del DevicePrx

    _M_SmartHome.Device = Ice.createTempClass()
    class Device(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::Device')

        def ice_id(self, current=None):
            return '::SmartHome::Device'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::Device'

        def setInfo(self, info, current=None):
            raise NotImplementedError("servant method 'setInfo' not implemented")

        def getInfo(self, current=None):
            raise NotImplementedError("servant method 'getInfo' not implemented")

        def isFailure(self, current=None):
            raise NotImplementedError("servant method 'isFailure' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_DeviceDisp)

        __repr__ = __str__

    _M_SmartHome._t_DeviceDisp = IcePy.defineClass('::SmartHome::Device', Device, (), None, ())
    Device._ice_type = _M_SmartHome._t_DeviceDisp

    Device._op_setInfo = IcePy.Operation('setInfo', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_SmartHome._t_Info, False, 0),), (), ((), _M_SmartHome._t_Info, False, 0), (_M_SmartHome._t_AlreadyWorkingError,))
    Device._op_getInfo = IcePy.Operation('getInfo', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), _M_SmartHome._t_Info, False, 0), ())
    Device._op_isFailure = IcePy.Operation('isFailure', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), None, (_M_SmartHome._t_DeviceFailureError,))

    _M_SmartHome.Device = Device
    del Device

if 'TemperatureOutOfRangeError' not in _M_SmartHome.__dict__:
    _M_SmartHome.TemperatureOutOfRangeError = Ice.createTempClass()
    class TemperatureOutOfRangeError(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHome::TemperatureOutOfRangeError'

    _M_SmartHome._t_TemperatureOutOfRangeError = IcePy.defineException('::SmartHome::TemperatureOutOfRangeError', TemperatureOutOfRangeError, (), False, None, ())
    TemperatureOutOfRangeError._ice_type = _M_SmartHome._t_TemperatureOutOfRangeError

    _M_SmartHome.TemperatureOutOfRangeError = TemperatureOutOfRangeError
    del TemperatureOutOfRangeError

_M_SmartHome._t_Thermostat = IcePy.defineValue('::SmartHome::Thermostat', Ice.Value, -1, (), False, True, None, ())

if 'ThermostatPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.ThermostatPrx = Ice.createTempClass()
    class ThermostatPrx(_M_SmartHome.DevicePrx):

        def setTemperature(self, temperature, context=None):
            return _M_SmartHome.Thermostat._op_setTemperature.invoke(self, ((temperature, ), context))

        def setTemperatureAsync(self, temperature, context=None):
            return _M_SmartHome.Thermostat._op_setTemperature.invokeAsync(self, ((temperature, ), context))

        def begin_setTemperature(self, temperature, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.Thermostat._op_setTemperature.begin(self, ((temperature, ), _response, _ex, _sent, context))

        def end_setTemperature(self, _r):
            return _M_SmartHome.Thermostat._op_setTemperature.end(self, _r)

        def getTemperature(self, context=None):
            return _M_SmartHome.Thermostat._op_getTemperature.invoke(self, ((), context))

        def getTemperatureAsync(self, context=None):
            return _M_SmartHome.Thermostat._op_getTemperature.invokeAsync(self, ((), context))

        def begin_getTemperature(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.Thermostat._op_getTemperature.begin(self, ((), _response, _ex, _sent, context))

        def end_getTemperature(self, _r):
            return _M_SmartHome.Thermostat._op_getTemperature.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.ThermostatPrx.ice_checkedCast(proxy, '::SmartHome::Thermostat', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.ThermostatPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::Thermostat'
    _M_SmartHome._t_ThermostatPrx = IcePy.defineProxy('::SmartHome::Thermostat', ThermostatPrx)

    _M_SmartHome.ThermostatPrx = ThermostatPrx
    del ThermostatPrx

    _M_SmartHome.Thermostat = Ice.createTempClass()
    class Thermostat(_M_SmartHome.Device):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::Device', '::SmartHome::Thermostat')

        def ice_id(self, current=None):
            return '::SmartHome::Thermostat'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::Thermostat'

        def setTemperature(self, temperature, current=None):
            raise NotImplementedError("servant method 'setTemperature' not implemented")

        def getTemperature(self, current=None):
            raise NotImplementedError("servant method 'getTemperature' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_ThermostatDisp)

        __repr__ = __str__

    _M_SmartHome._t_ThermostatDisp = IcePy.defineClass('::SmartHome::Thermostat', Thermostat, (), None, (_M_SmartHome._t_DeviceDisp,))
    Thermostat._ice_type = _M_SmartHome._t_ThermostatDisp

    Thermostat._op_setTemperature = IcePy.Operation('setTemperature', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_double, False, 0),), (), None, (_M_SmartHome._t_TemperatureOutOfRangeError,))
    Thermostat._op_getTemperature = IcePy.Operation('getTemperature', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_double, False, 0), ())

    _M_SmartHome.Thermostat = Thermostat
    del Thermostat

if 'DaySchedule' not in _M_SmartHome.__dict__:
    _M_SmartHome.DaySchedule = Ice.createTempClass()
    class DaySchedule(object):
        def __init__(self, dayOfWeek='', openHour=0, openMinutes=0, closeHour=0, closeMinutes=0):
            self.dayOfWeek = dayOfWeek
            self.openHour = openHour
            self.openMinutes = openMinutes
            self.closeHour = closeHour
            self.closeMinutes = closeMinutes

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.dayOfWeek)
            _h = 5 * _h + Ice.getHash(self.openHour)
            _h = 5 * _h + Ice.getHash(self.openMinutes)
            _h = 5 * _h + Ice.getHash(self.closeHour)
            _h = 5 * _h + Ice.getHash(self.closeMinutes)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_SmartHome.DaySchedule):
                return NotImplemented
            else:
                if self.dayOfWeek is None or other.dayOfWeek is None:
                    if self.dayOfWeek != other.dayOfWeek:
                        return (-1 if self.dayOfWeek is None else 1)
                else:
                    if self.dayOfWeek < other.dayOfWeek:
                        return -1
                    elif self.dayOfWeek > other.dayOfWeek:
                        return 1
                if self.openHour is None or other.openHour is None:
                    if self.openHour != other.openHour:
                        return (-1 if self.openHour is None else 1)
                else:
                    if self.openHour < other.openHour:
                        return -1
                    elif self.openHour > other.openHour:
                        return 1
                if self.openMinutes is None or other.openMinutes is None:
                    if self.openMinutes != other.openMinutes:
                        return (-1 if self.openMinutes is None else 1)
                else:
                    if self.openMinutes < other.openMinutes:
                        return -1
                    elif self.openMinutes > other.openMinutes:
                        return 1
                if self.closeHour is None or other.closeHour is None:
                    if self.closeHour != other.closeHour:
                        return (-1 if self.closeHour is None else 1)
                else:
                    if self.closeHour < other.closeHour:
                        return -1
                    elif self.closeHour > other.closeHour:
                        return 1
                if self.closeMinutes is None or other.closeMinutes is None:
                    if self.closeMinutes != other.closeMinutes:
                        return (-1 if self.closeMinutes is None else 1)
                else:
                    if self.closeMinutes < other.closeMinutes:
                        return -1
                    elif self.closeMinutes > other.closeMinutes:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_DaySchedule)

        __repr__ = __str__

    _M_SmartHome._t_DaySchedule = IcePy.defineStruct('::SmartHome::DaySchedule', DaySchedule, (), (
        ('dayOfWeek', (), IcePy._t_string),
        ('openHour', (), IcePy._t_int),
        ('openMinutes', (), IcePy._t_int),
        ('closeHour', (), IcePy._t_int),
        ('closeMinutes', (), IcePy._t_int)
    ))

    _M_SmartHome.DaySchedule = DaySchedule
    del DaySchedule

if '_t_Schedule' not in _M_SmartHome.__dict__:
    _M_SmartHome._t_Schedule = IcePy.defineSequence('::SmartHome::Schedule', (), _M_SmartHome._t_DaySchedule)

if 'CoffeeTime' not in _M_SmartHome.__dict__:
    _M_SmartHome.CoffeeTime = Ice.createTempClass()
    class CoffeeTime(object):
        def __init__(self, startHour=0, startMinute=0):
            self.startHour = startHour
            self.startMinute = startMinute

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.startHour)
            _h = 5 * _h + Ice.getHash(self.startMinute)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_SmartHome.CoffeeTime):
                return NotImplemented
            else:
                if self.startHour is None or other.startHour is None:
                    if self.startHour != other.startHour:
                        return (-1 if self.startHour is None else 1)
                else:
                    if self.startHour < other.startHour:
                        return -1
                    elif self.startHour > other.startHour:
                        return 1
                if self.startMinute is None or other.startMinute is None:
                    if self.startMinute != other.startMinute:
                        return (-1 if self.startMinute is None else 1)
                else:
                    if self.startMinute < other.startMinute:
                        return -1
                    elif self.startMinute > other.startMinute:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_CoffeeTime)

        __repr__ = __str__

    _M_SmartHome._t_CoffeeTime = IcePy.defineStruct('::SmartHome::CoffeeTime', CoffeeTime, (), (
        ('startHour', (), IcePy._t_int),
        ('startMinute', (), IcePy._t_int)
    ))

    _M_SmartHome.CoffeeTime = CoffeeTime
    del CoffeeTime

if '_t_CoffeeTimes' not in _M_SmartHome.__dict__:
    _M_SmartHome._t_CoffeeTimes = IcePy.defineSequence('::SmartHome::CoffeeTimes', (), _M_SmartHome._t_CoffeeTime)

if 'TooManyShedulesError' not in _M_SmartHome.__dict__:
    _M_SmartHome.TooManyShedulesError = Ice.createTempClass()
    class TooManyShedulesError(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHome::TooManyShedulesError'

    _M_SmartHome._t_TooManyShedulesError = IcePy.defineException('::SmartHome::TooManyShedulesError', TooManyShedulesError, (), False, None, ())
    TooManyShedulesError._ice_type = _M_SmartHome._t_TooManyShedulesError

    _M_SmartHome.TooManyShedulesError = TooManyShedulesError
    del TooManyShedulesError

if 'HoursOutOfRangeError' not in _M_SmartHome.__dict__:
    _M_SmartHome.HoursOutOfRangeError = Ice.createTempClass()
    class HoursOutOfRangeError(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHome::HoursOutOfRangeError'

    _M_SmartHome._t_HoursOutOfRangeError = IcePy.defineException('::SmartHome::HoursOutOfRangeError', HoursOutOfRangeError, (), False, None, ())
    HoursOutOfRangeError._ice_type = _M_SmartHome._t_HoursOutOfRangeError

    _M_SmartHome.HoursOutOfRangeError = HoursOutOfRangeError
    del HoursOutOfRangeError

if 'MinutesOutOffRangeError' not in _M_SmartHome.__dict__:
    _M_SmartHome.MinutesOutOffRangeError = Ice.createTempClass()
    class MinutesOutOffRangeError(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHome::MinutesOutOffRangeError'

    _M_SmartHome._t_MinutesOutOffRangeError = IcePy.defineException('::SmartHome::MinutesOutOffRangeError', MinutesOutOffRangeError, (), False, None, ())
    MinutesOutOffRangeError._ice_type = _M_SmartHome._t_MinutesOutOffRangeError

    _M_SmartHome.MinutesOutOffRangeError = MinutesOutOffRangeError
    del MinutesOutOffRangeError

_M_SmartHome._t_CoffeeMaker = IcePy.defineValue('::SmartHome::CoffeeMaker', Ice.Value, -1, (), False, True, None, ())

if 'CoffeeMakerPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.CoffeeMakerPrx = Ice.createTempClass()
    class CoffeeMakerPrx(_M_SmartHome.DevicePrx):

        def brewCoffee(self, context=None):
            return _M_SmartHome.CoffeeMaker._op_brewCoffee.invoke(self, ((), context))

        def brewCoffeeAsync(self, context=None):
            return _M_SmartHome.CoffeeMaker._op_brewCoffee.invokeAsync(self, ((), context))

        def begin_brewCoffee(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.CoffeeMaker._op_brewCoffee.begin(self, ((), _response, _ex, _sent, context))

        def end_brewCoffee(self, _r):
            return _M_SmartHome.CoffeeMaker._op_brewCoffee.end(self, _r)

        def setSchedule(self, coffeeTimes, context=None):
            return _M_SmartHome.CoffeeMaker._op_setSchedule.invoke(self, ((coffeeTimes, ), context))

        def setScheduleAsync(self, coffeeTimes, context=None):
            return _M_SmartHome.CoffeeMaker._op_setSchedule.invokeAsync(self, ((coffeeTimes, ), context))

        def begin_setSchedule(self, coffeeTimes, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.CoffeeMaker._op_setSchedule.begin(self, ((coffeeTimes, ), _response, _ex, _sent, context))

        def end_setSchedule(self, _r):
            return _M_SmartHome.CoffeeMaker._op_setSchedule.end(self, _r)

        def changeDaySchedule(self, coffeeTime, context=None):
            return _M_SmartHome.CoffeeMaker._op_changeDaySchedule.invoke(self, ((coffeeTime, ), context))

        def changeDayScheduleAsync(self, coffeeTime, context=None):
            return _M_SmartHome.CoffeeMaker._op_changeDaySchedule.invokeAsync(self, ((coffeeTime, ), context))

        def begin_changeDaySchedule(self, coffeeTime, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.CoffeeMaker._op_changeDaySchedule.begin(self, ((coffeeTime, ), _response, _ex, _sent, context))

        def end_changeDaySchedule(self, _r):
            return _M_SmartHome.CoffeeMaker._op_changeDaySchedule.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.CoffeeMakerPrx.ice_checkedCast(proxy, '::SmartHome::CoffeeMaker', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.CoffeeMakerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::CoffeeMaker'
    _M_SmartHome._t_CoffeeMakerPrx = IcePy.defineProxy('::SmartHome::CoffeeMaker', CoffeeMakerPrx)

    _M_SmartHome.CoffeeMakerPrx = CoffeeMakerPrx
    del CoffeeMakerPrx

    _M_SmartHome.CoffeeMaker = Ice.createTempClass()
    class CoffeeMaker(_M_SmartHome.Device):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::CoffeeMaker', '::SmartHome::Device')

        def ice_id(self, current=None):
            return '::SmartHome::CoffeeMaker'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::CoffeeMaker'

        def brewCoffee(self, current=None):
            raise NotImplementedError("servant method 'brewCoffee' not implemented")

        def setSchedule(self, coffeeTimes, current=None):
            raise NotImplementedError("servant method 'setSchedule' not implemented")

        def changeDaySchedule(self, coffeeTime, current=None):
            raise NotImplementedError("servant method 'changeDaySchedule' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_CoffeeMakerDisp)

        __repr__ = __str__

    _M_SmartHome._t_CoffeeMakerDisp = IcePy.defineClass('::SmartHome::CoffeeMaker', CoffeeMaker, (), None, (_M_SmartHome._t_DeviceDisp,))
    CoffeeMaker._ice_type = _M_SmartHome._t_CoffeeMakerDisp

    CoffeeMaker._op_brewCoffee = IcePy.Operation('brewCoffee', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    CoffeeMaker._op_setSchedule = IcePy.Operation('setSchedule', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHome._t_CoffeeTimes, False, 0),), (), None, (_M_SmartHome._t_TooManyShedulesError, _M_SmartHome._t_HoursOutOfRangeError, _M_SmartHome._t_MinutesOutOffRangeError))
    CoffeeMaker._op_changeDaySchedule = IcePy.Operation('changeDaySchedule', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHome._t_CoffeeTime, False, 0),), (), None, (_M_SmartHome._t_HoursOutOfRangeError, _M_SmartHome._t_MinutesOutOffRangeError))

    _M_SmartHome.CoffeeMaker = CoffeeMaker
    del CoffeeMaker

if 'AngleOutOfRangeError' not in _M_SmartHome.__dict__:
    _M_SmartHome.AngleOutOfRangeError = Ice.createTempClass()
    class AngleOutOfRangeError(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHome::AngleOutOfRangeError'

    _M_SmartHome._t_AngleOutOfRangeError = IcePy.defineException('::SmartHome::AngleOutOfRangeError', AngleOutOfRangeError, (), False, None, ())
    AngleOutOfRangeError._ice_type = _M_SmartHome._t_AngleOutOfRangeError

    _M_SmartHome.AngleOutOfRangeError = AngleOutOfRangeError
    del AngleOutOfRangeError

if 'CoverageOutOfRangeError' not in _M_SmartHome.__dict__:
    _M_SmartHome.CoverageOutOfRangeError = Ice.createTempClass()
    class CoverageOutOfRangeError(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHome::CoverageOutOfRangeError'

    _M_SmartHome._t_CoverageOutOfRangeError = IcePy.defineException('::SmartHome::CoverageOutOfRangeError', CoverageOutOfRangeError, (), False, None, ())
    CoverageOutOfRangeError._ice_type = _M_SmartHome._t_CoverageOutOfRangeError

    _M_SmartHome.CoverageOutOfRangeError = CoverageOutOfRangeError
    del CoverageOutOfRangeError

_M_SmartHome._t_SmartBlind = IcePy.defineValue('::SmartHome::SmartBlind', Ice.Value, -1, (), False, True, None, ())

if 'SmartBlindPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.SmartBlindPrx = Ice.createTempClass()
    class SmartBlindPrx(_M_SmartHome.DevicePrx):

        def openBlind(self, context=None):
            return _M_SmartHome.SmartBlind._op_openBlind.invoke(self, ((), context))

        def openBlindAsync(self, context=None):
            return _M_SmartHome.SmartBlind._op_openBlind.invokeAsync(self, ((), context))

        def begin_openBlind(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.SmartBlind._op_openBlind.begin(self, ((), _response, _ex, _sent, context))

        def end_openBlind(self, _r):
            return _M_SmartHome.SmartBlind._op_openBlind.end(self, _r)

        def closeBlind(self, context=None):
            return _M_SmartHome.SmartBlind._op_closeBlind.invoke(self, ((), context))

        def closeBlindAsync(self, context=None):
            return _M_SmartHome.SmartBlind._op_closeBlind.invokeAsync(self, ((), context))

        def begin_closeBlind(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.SmartBlind._op_closeBlind.begin(self, ((), _response, _ex, _sent, context))

        def end_closeBlind(self, _r):
            return _M_SmartHome.SmartBlind._op_closeBlind.end(self, _r)

        def setAngle(self, angle, context=None):
            return _M_SmartHome.SmartBlind._op_setAngle.invoke(self, ((angle, ), context))

        def setAngleAsync(self, angle, context=None):
            return _M_SmartHome.SmartBlind._op_setAngle.invokeAsync(self, ((angle, ), context))

        def begin_setAngle(self, angle, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.SmartBlind._op_setAngle.begin(self, ((angle, ), _response, _ex, _sent, context))

        def end_setAngle(self, _r):
            return _M_SmartHome.SmartBlind._op_setAngle.end(self, _r)

        def setFullWindowCoverage(self, fullCoverage, context=None):
            return _M_SmartHome.SmartBlind._op_setFullWindowCoverage.invoke(self, ((fullCoverage, ), context))

        def setFullWindowCoverageAsync(self, fullCoverage, context=None):
            return _M_SmartHome.SmartBlind._op_setFullWindowCoverage.invokeAsync(self, ((fullCoverage, ), context))

        def begin_setFullWindowCoverage(self, fullCoverage, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.SmartBlind._op_setFullWindowCoverage.begin(self, ((fullCoverage, ), _response, _ex, _sent, context))

        def end_setFullWindowCoverage(self, _r):
            return _M_SmartHome.SmartBlind._op_setFullWindowCoverage.end(self, _r)

        def setCustomWindowCoverage(self, coverage, context=None):
            return _M_SmartHome.SmartBlind._op_setCustomWindowCoverage.invoke(self, ((coverage, ), context))

        def setCustomWindowCoverageAsync(self, coverage, context=None):
            return _M_SmartHome.SmartBlind._op_setCustomWindowCoverage.invokeAsync(self, ((coverage, ), context))

        def begin_setCustomWindowCoverage(self, coverage, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.SmartBlind._op_setCustomWindowCoverage.begin(self, ((coverage, ), _response, _ex, _sent, context))

        def end_setCustomWindowCoverage(self, _r):
            return _M_SmartHome.SmartBlind._op_setCustomWindowCoverage.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.SmartBlindPrx.ice_checkedCast(proxy, '::SmartHome::SmartBlind', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.SmartBlindPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::SmartBlind'
    _M_SmartHome._t_SmartBlindPrx = IcePy.defineProxy('::SmartHome::SmartBlind', SmartBlindPrx)

    _M_SmartHome.SmartBlindPrx = SmartBlindPrx
    del SmartBlindPrx

    _M_SmartHome.SmartBlind = Ice.createTempClass()
    class SmartBlind(_M_SmartHome.Device):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::Device', '::SmartHome::SmartBlind')

        def ice_id(self, current=None):
            return '::SmartHome::SmartBlind'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::SmartBlind'

        def openBlind(self, current=None):
            raise NotImplementedError("servant method 'openBlind' not implemented")

        def closeBlind(self, current=None):
            raise NotImplementedError("servant method 'closeBlind' not implemented")

        def setAngle(self, angle, current=None):
            raise NotImplementedError("servant method 'setAngle' not implemented")

        def setFullWindowCoverage(self, fullCoverage, current=None):
            raise NotImplementedError("servant method 'setFullWindowCoverage' not implemented")

        def setCustomWindowCoverage(self, coverage, current=None):
            raise NotImplementedError("servant method 'setCustomWindowCoverage' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_SmartBlindDisp)

        __repr__ = __str__

    _M_SmartHome._t_SmartBlindDisp = IcePy.defineClass('::SmartHome::SmartBlind', SmartBlind, (), None, (_M_SmartHome._t_DeviceDisp,))
    SmartBlind._ice_type = _M_SmartHome._t_SmartBlindDisp

    SmartBlind._op_openBlind = IcePy.Operation('openBlind', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    SmartBlind._op_closeBlind = IcePy.Operation('closeBlind', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    SmartBlind._op_setAngle = IcePy.Operation('setAngle', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_double, False, 0),), (), None, (_M_SmartHome._t_AngleOutOfRangeError,))
    SmartBlind._op_setFullWindowCoverage = IcePy.Operation('setFullWindowCoverage', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_bool, False, 0),), (), None, (_M_SmartHome._t_CoverageOutOfRangeError,))
    SmartBlind._op_setCustomWindowCoverage = IcePy.Operation('setCustomWindowCoverage', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_double, False, 0),), (), None, ())

    _M_SmartHome.SmartBlind = SmartBlind
    del SmartBlind

_M_SmartHome._t_DailyScheduleBlind = IcePy.defineValue('::SmartHome::DailyScheduleBlind', Ice.Value, -1, (), False, True, None, ())

if 'DailyScheduleBlindPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.DailyScheduleBlindPrx = Ice.createTempClass()
    class DailyScheduleBlindPrx(_M_SmartHome.SmartBlindPrx):

        def changeDaySchedule(self, daySchedule, context=None):
            return _M_SmartHome.DailyScheduleBlind._op_changeDaySchedule.invoke(self, ((daySchedule, ), context))

        def changeDayScheduleAsync(self, daySchedule, context=None):
            return _M_SmartHome.DailyScheduleBlind._op_changeDaySchedule.invokeAsync(self, ((daySchedule, ), context))

        def begin_changeDaySchedule(self, daySchedule, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.DailyScheduleBlind._op_changeDaySchedule.begin(self, ((daySchedule, ), _response, _ex, _sent, context))

        def end_changeDaySchedule(self, _r):
            return _M_SmartHome.DailyScheduleBlind._op_changeDaySchedule.end(self, _r)

        def setSchedule(self, schedule, context=None):
            return _M_SmartHome.DailyScheduleBlind._op_setSchedule.invoke(self, ((schedule, ), context))

        def setScheduleAsync(self, schedule, context=None):
            return _M_SmartHome.DailyScheduleBlind._op_setSchedule.invokeAsync(self, ((schedule, ), context))

        def begin_setSchedule(self, schedule, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.DailyScheduleBlind._op_setSchedule.begin(self, ((schedule, ), _response, _ex, _sent, context))

        def end_setSchedule(self, _r):
            return _M_SmartHome.DailyScheduleBlind._op_setSchedule.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.DailyScheduleBlindPrx.ice_checkedCast(proxy, '::SmartHome::DailyScheduleBlind', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.DailyScheduleBlindPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::DailyScheduleBlind'
    _M_SmartHome._t_DailyScheduleBlindPrx = IcePy.defineProxy('::SmartHome::DailyScheduleBlind', DailyScheduleBlindPrx)

    _M_SmartHome.DailyScheduleBlindPrx = DailyScheduleBlindPrx
    del DailyScheduleBlindPrx

    _M_SmartHome.DailyScheduleBlind = Ice.createTempClass()
    class DailyScheduleBlind(_M_SmartHome.SmartBlind):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::DailyScheduleBlind', '::SmartHome::Device', '::SmartHome::SmartBlind')

        def ice_id(self, current=None):
            return '::SmartHome::DailyScheduleBlind'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::DailyScheduleBlind'

        def changeDaySchedule(self, daySchedule, current=None):
            raise NotImplementedError("servant method 'changeDaySchedule' not implemented")

        def setSchedule(self, schedule, current=None):
            raise NotImplementedError("servant method 'setSchedule' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_DailyScheduleBlindDisp)

        __repr__ = __str__

    _M_SmartHome._t_DailyScheduleBlindDisp = IcePy.defineClass('::SmartHome::DailyScheduleBlind', DailyScheduleBlind, (), None, (_M_SmartHome._t_SmartBlindDisp,))
    DailyScheduleBlind._ice_type = _M_SmartHome._t_DailyScheduleBlindDisp

    DailyScheduleBlind._op_changeDaySchedule = IcePy.Operation('changeDaySchedule', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHome._t_DaySchedule, False, 0),), (), None, (_M_SmartHome._t_HoursOutOfRangeError, _M_SmartHome._t_MinutesOutOffRangeError))
    DailyScheduleBlind._op_setSchedule = IcePy.Operation('setSchedule', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHome._t_Schedule, False, 0),), (), None, (_M_SmartHome._t_TooManyShedulesError, _M_SmartHome._t_HoursOutOfRangeError, _M_SmartHome._t_MinutesOutOffRangeError))

    _M_SmartHome.DailyScheduleBlind = DailyScheduleBlind
    del DailyScheduleBlind

if 'AlarmAlreadyOnError' not in _M_SmartHome.__dict__:
    _M_SmartHome.AlarmAlreadyOnError = Ice.createTempClass()
    class AlarmAlreadyOnError(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHome::AlarmAlreadyOnError'

    _M_SmartHome._t_AlarmAlreadyOnError = IcePy.defineException('::SmartHome::AlarmAlreadyOnError', AlarmAlreadyOnError, (), False, None, ())
    AlarmAlreadyOnError._ice_type = _M_SmartHome._t_AlarmAlreadyOnError

    _M_SmartHome.AlarmAlreadyOnError = AlarmAlreadyOnError
    del AlarmAlreadyOnError

if 'AlarmAlreadyOffError' not in _M_SmartHome.__dict__:
    _M_SmartHome.AlarmAlreadyOffError = Ice.createTempClass()
    class AlarmAlreadyOffError(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHome::AlarmAlreadyOffError'

    _M_SmartHome._t_AlarmAlreadyOffError = IcePy.defineException('::SmartHome::AlarmAlreadyOffError', AlarmAlreadyOffError, (), False, None, ())
    AlarmAlreadyOffError._ice_type = _M_SmartHome._t_AlarmAlreadyOffError

    _M_SmartHome.AlarmAlreadyOffError = AlarmAlreadyOffError
    del AlarmAlreadyOffError

_M_SmartHome._t_AlarmTriggeredBlind = IcePy.defineValue('::SmartHome::AlarmTriggeredBlind', Ice.Value, -1, (), False, True, None, ())

if 'AlarmTriggeredBlindPrx' not in _M_SmartHome.__dict__:
    _M_SmartHome.AlarmTriggeredBlindPrx = Ice.createTempClass()
    class AlarmTriggeredBlindPrx(_M_SmartHome.SmartBlindPrx):

        def activateAlarmMode(self, context=None):
            return _M_SmartHome.AlarmTriggeredBlind._op_activateAlarmMode.invoke(self, ((), context))

        def activateAlarmModeAsync(self, context=None):
            return _M_SmartHome.AlarmTriggeredBlind._op_activateAlarmMode.invokeAsync(self, ((), context))

        def begin_activateAlarmMode(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.AlarmTriggeredBlind._op_activateAlarmMode.begin(self, ((), _response, _ex, _sent, context))

        def end_activateAlarmMode(self, _r):
            return _M_SmartHome.AlarmTriggeredBlind._op_activateAlarmMode.end(self, _r)

        def deactivateAlarmMode(self, context=None):
            return _M_SmartHome.AlarmTriggeredBlind._op_deactivateAlarmMode.invoke(self, ((), context))

        def deactivateAlarmModeAsync(self, context=None):
            return _M_SmartHome.AlarmTriggeredBlind._op_deactivateAlarmMode.invokeAsync(self, ((), context))

        def begin_deactivateAlarmMode(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHome.AlarmTriggeredBlind._op_deactivateAlarmMode.begin(self, ((), _response, _ex, _sent, context))

        def end_deactivateAlarmMode(self, _r):
            return _M_SmartHome.AlarmTriggeredBlind._op_deactivateAlarmMode.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHome.AlarmTriggeredBlindPrx.ice_checkedCast(proxy, '::SmartHome::AlarmTriggeredBlind', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHome.AlarmTriggeredBlindPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHome::AlarmTriggeredBlind'
    _M_SmartHome._t_AlarmTriggeredBlindPrx = IcePy.defineProxy('::SmartHome::AlarmTriggeredBlind', AlarmTriggeredBlindPrx)

    _M_SmartHome.AlarmTriggeredBlindPrx = AlarmTriggeredBlindPrx
    del AlarmTriggeredBlindPrx

    _M_SmartHome.AlarmTriggeredBlind = Ice.createTempClass()
    class AlarmTriggeredBlind(_M_SmartHome.SmartBlind):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHome::AlarmTriggeredBlind', '::SmartHome::Device', '::SmartHome::SmartBlind')

        def ice_id(self, current=None):
            return '::SmartHome::AlarmTriggeredBlind'

        @staticmethod
        def ice_staticId():
            return '::SmartHome::AlarmTriggeredBlind'

        def activateAlarmMode(self, current=None):
            raise NotImplementedError("servant method 'activateAlarmMode' not implemented")

        def deactivateAlarmMode(self, current=None):
            raise NotImplementedError("servant method 'deactivateAlarmMode' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHome._t_AlarmTriggeredBlindDisp)

        __repr__ = __str__

    _M_SmartHome._t_AlarmTriggeredBlindDisp = IcePy.defineClass('::SmartHome::AlarmTriggeredBlind', AlarmTriggeredBlind, (), None, (_M_SmartHome._t_SmartBlindDisp,))
    AlarmTriggeredBlind._ice_type = _M_SmartHome._t_AlarmTriggeredBlindDisp

    AlarmTriggeredBlind._op_activateAlarmMode = IcePy.Operation('activateAlarmMode', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_SmartHome._t_AlarmAlreadyOnError,))
    AlarmTriggeredBlind._op_deactivateAlarmMode = IcePy.Operation('deactivateAlarmMode', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_SmartHome._t_AlarmAlreadyOffError,))

    _M_SmartHome.AlarmTriggeredBlind = AlarmTriggeredBlind
    del AlarmTriggeredBlind

# End of module SmartHome
